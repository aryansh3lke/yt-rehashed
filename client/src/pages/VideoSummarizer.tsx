import "../styles/App.css";
import { useState } from "react";
import LinkForm from "../components/LinkForm";
import Loader from "../components/Loader";
import VideoPlayer from "../components/VideoPlayer";
import CommentSection from "../components/CommentSection";
import SummaryBox from "../components/SummaryBox";
import DownloadModal from "../components/DownloadModal";
import ErrorAlert from "../components/ErrorAlert";
import { Caption, Comment, Resolution } from "../types/interfaces";
import { generateValidFilename } from "../utils";
import { PROXY_URL } from "../proxy";

export default function VideoSummarizer() {
  const [inputLink, setInputLink] = useState<string>("");
  const [videoId, setVideoId] = useState<string>("");
  const [videoTitle, setVideoTitle] = useState<string>("");
  const [seekTime, setSeekTime] = useState<number>(0);
  const [captions, setCaptions] = useState<Caption[]>([]);
  const [comments, setComments] = useState<Comment[]>([]);
  const [videoSummary, setVideoSummary] = useState<string>("");
  const [commentSummary, setCommentSummary] = useState<string>("");
  const [summaryLoader, setSummaryLoader] = useState<boolean>(false);
  const [alert, setAlert] = useState<string>("");

  const [downloadModal, setDownloadModal] = useState<boolean>(false);
  const [downloadLoader, setDownloadLoader] = useState<boolean>(false);
  const [downloadResolutions, setDownloadResolutions] = useState<Resolution[]>(
    [],
  );
  const [downloadError, setDownloadError] = useState<string>("");

  const [selectedResolution, setSelectedResolution] = useState<Resolution>("");
  const [isDownloading, setIsDownloading] = useState<boolean>(false);

  /**
   * Generate summaries for a YouTube video based on the provided URL.
   *
   * This function is triggered by clicking the submit button for the link form.
   * It fetches summaries from the server generated by ChatGPT and updates state
   * hooks with the fetched data.
   */
  const generateSummaries = async (e: React.FormEvent) => {
    e.preventDefault();
    const videoUrl: string = inputLink;

    // clear relevant state hooks
    setInputLink("");
    setVideoId("");
    setVideoTitle("");
    setSeekTime(0);
    setCaptions([]);
    setComments([]);
    setVideoSummary("");
    setCommentSummary("");
    setAlert("");
    setDownloadResolutions([]);
    setSelectedResolution("");
    setDownloadError("");

    setSummaryLoader(true);

    fetch(PROXY_URL + `/api/get-summaries?video_url=${videoUrl}`)
      .then((response) =>
        response
          .json()
          .then((data) => ({ status: response.status, body: data })),
      )
      .then(({ status, body }) => {
        if (status !== 200) {
          throw new Error(body.error);
        }

        // initalize relevant state hooks
        setSummaryLoader(false);
        setVideoId(body.video_id);
        setVideoTitle(body.video_title);
        setCaptions(body.captions);
        setComments(body.comments);
        setVideoSummary(body.video_summary);
        setCommentSummary(body.comments_summary);
      })
      .catch((error) => {
        if (error.message === "Failed to fetch") {
          error.message =
            "The servers are currently down. Please try again later.";
        }
        setSummaryLoader(false);
        setAlert(error.message);
      });
  };

  /**
   * Display the available resolutions to download for the given YouTube video.
   *
   * This function is triggered by opening up the download modal for the first
   * time for the current video. It fetches the resolutions from the server
   * based on the video streams that are available through YouTube.
   */
  const displayResolutions = async (e: React.MouseEvent) => {
    e.preventDefault();

    if (downloadResolutions.length === 0) {
      // update downloader state hooks
      setDownloadModal(true);
      setDownloadLoader(true);
      setDownloadResolutions([]);

      fetch(PROXY_URL + `/api/get-resolutions?video_id=${videoId}`)
        .then((response) =>
          response
            .json()
            .then((data) => ({ status: response.status, body: data })),
        )
        .then(({ status, body }) => {
          if (status !== 200) {
            throw new Error(body.error);
          }
          setDownloadLoader(false);
          setDownloadResolutions(body.resolutions);
        })
        .catch((error) => {
          setDownloadModal(false);
          setDownloadLoader(false);
          setAlert(error.message);
        });
    } else {
      // avoid reloading resolutions if already done once for the video
      setDownloadModal(true);
    }
  };

  /**
   * Handle the download of a YouTube video based on the selected resolution.
   *
   * This function is triggered by clicking the download button on the download
   * modal. It checks if a resolution is selected and fetches the download URL
   * from the server. If the URL is successfully retrieved, it creates a link
   * element to initiate the download of the video as a file attachment.
   */
  const downloadVideo = async (e: React.MouseEvent) => {
    e.preventDefault();

    if (selectedResolution === "") {
      // throw warning if no resolution is selected
      setDownloadError("Please select a resolution!");
    } else {
      try {
        setIsDownloading(true);
        const response = await fetch(
          PROXY_URL +
            `/api/get-download?video_id=${videoId}&video_resolution=${selectedResolution}`,
        );

        if (!response.ok) {
          throw new Error("Network response was not ok");
        }

        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${generateValidFilename(videoTitle)} [${selectedResolution}].mp4`; // You can customize the filename as needed
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
        setIsDownloading(false);
      } catch (error) {
        setIsDownloading(false);
        setDownloadError("An error occurred while downloading the video.");
      }
    }
  };

  return (
    <div className="flex flex-col items-center justify-center gap-5">
      {alert && <ErrorAlert message={alert} setMessage={setAlert} />}

      <LinkForm
        title="Video Summarizer"
        prompt={
          "Enter your YouTube video link to get a detailed summary of the transcript and comments"
        }
        placeholder={"https://www.youtube.com/watch?v="}
        inputLink={inputLink}
        setInputLink={setInputLink}
        onSubmit={generateSummaries}
        submitText="Summarize"
      />

      <Loader loaderTrigger={summaryLoader} loaderType={"summary-loader"} />

      {videoSummary && (
        <div className="result">
          <VideoPlayer
            videoId={videoId}
            captions={captions}
            seekTime={seekTime}
            setSeekTime={setSeekTime}
            displayResolutions={displayResolutions}
            animationDelay={0}
          />
          {/* <TranscriptBox
              captions={captions}
              setSeekTime={setSeekTime}
              animationDelay={0.5}
            /> */}
          <SummaryBox
            summaryTitle={"Video Summary"}
            summaryText={videoSummary}
            animationDelay={0.75}
          />
        </div>
      )}

      {commentSummary && (
        <div className="result">
          <CommentSection comments={comments} animationDelay={1.25} />
          <SummaryBox
            summaryTitle={"Comments Summary"}
            summaryText={commentSummary}
            animationDelay={2}
          />
        </div>
      )}

      <DownloadModal
        downloadModal={downloadModal}
        setDownloadModal={setDownloadModal}
        downloadLoader={downloadLoader}
        downloadResolutions={downloadResolutions}
        selectedResolution={selectedResolution}
        setSelectedResolution={setSelectedResolution}
        downloadError={downloadError}
        setDownloadError={setDownloadError}
        progressEndpoint={PROXY_URL + "/api/get-progress"}
        isDownloading={isDownloading}
        downloadVideo={downloadVideo}
      />
    </div>
  );
}
